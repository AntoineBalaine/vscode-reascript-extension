[
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "mediaitem", "item", "track", "empty"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Creates a new media item. It will be empty and therefore not be shown in the arrange-view, until you associate a mediafile(audio, picture, video, etc) or a length and position to it using [SetMediaItemInfo\\_Value](#SetMediaItemInfo_Value)",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaTrack tr",
          "description": "tracknumber(zero based), with 0 for track 1, 1 for track 2, etc."
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "AddMediaItemToTrack",
    "functioncall": {
      "lua": "MediaItem item = reaper.AddMediaItemToTrack(MediaTrack tr)",
      "cpp": "MediaItem* item AddMediaItemToTrack(MediaTrack* tr)",
      "python": "MediaItem item RPR_AddMediaItemToTrack(MediaTrack tr)",
      "eel": "MediaItem item AddMediaItemToTrack(MediaTrack tr)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "MediaItem item", "description": "the newly created MediaItem-object" }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "tr", "type": "MediaTrack" }],
        "method_name": "reaper.AddMediaItemToTrack",
        "return_values": [{ "identifier": "item", "type": "MediaItem" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Marker Management"],
    "tags": [
      "markermanagement",
      "region",
      "marker",
      "name",
      "shownnumber",
      "pos",
      "project",
      "add"
    ],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Creates a new Projectmarker/Region.\nReturns the index of the created marker/region, or -1 on failure. Supply wantidx&gt;=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use.",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project, in which to add the new marker; use 0 for the current project; can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        },
        {
          "identifier": "boolean isrgn",
          "description": "true, if it shall be a region; false, if a normal marker"
        },
        {
          "identifier": "number pos",
          "description": "the position of the newly created marker/region in seconds"
        },
        {
          "identifier": "number rgnend",
          "description": "if the marker is a region, this is the end of the region in seconds"
        },
        { "identifier": "string name", "description": "the shown name of the marker" },
        {
          "identifier": "integer wantidx",
          "description": "the shown number of the marker/region. Markers can have the same shown marker multiple times. Regions will get another number, if wantidx is already given."
        }
      ],
      "param_count": 6,
      "markup_type": "plaintext"
    },
    "title": "AddProjectMarker",
    "functioncall": {
      "lua": "integer = reaper.AddProjectMarker(ReaProject proj, boolean isrgn, number pos, number rgnend, string name, integer wantidx)",
      "cpp": "int AddProjectMarker(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx)",
      "python": "Int RPR_AddProjectMarker(ReaProject proj, Boolean isrgn, Float pos, Float rgnend, String name, Int wantidx)",
      "eel": "int AddProjectMarker(ReaProject proj, bool isrgn, pos, rgnend, \"name\", int wantidx)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the shown-number of the newly created marker/region"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "proj", "type": "ReaProject" },
          { "identifier": "isrgn", "type": "boolean" },
          { "identifier": "pos", "type": "number" },
          { "identifier": "rgnend", "type": "number" },
          { "identifier": "name", "type": "string" },
          { "identifier": "wantidx", "type": "integer" }
        ],
        "method_name": "reaper.AddProjectMarker",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Marker Management"],
    "tags": [
      "markermanagement",
      "region",
      "marker",
      "name",
      "shownnumber",
      "pos",
      "project",
      "add"
    ],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Returns the index of the created marker/region, or -1 on failure. Supply wantidx&gt;=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use. color should be 0 (default color), or [ColorToNative(r,g,b)|0x1000000](#ColorToNative)",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project, in which to add the new marker; use 0 for the current project; can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        },
        {
          "identifier": "boolean isrgn",
          "description": "true, if it shall be a region; false, if a normal marker"
        },
        {
          "identifier": "number pos",
          "description": "the position of the newly created marker/region in seconds"
        },
        {
          "identifier": "number rgnend",
          "description": "if the marker is a region, this is the end of the region in seconds"
        },
        { "identifier": "string name", "description": "the shown name of the marker" },
        {
          "identifier": "integer wantidx",
          "description": "the shown number of the marker/region. Markers can have the same shown marker multiple times. Regions will get another number, if wantidx is already given."
        },
        {
          "identifier": "integer color",
          "description": "the color as returned by the function [ColorToNative(r,g,b)|0x1000000](#ColorToNative)"
        }
      ],
      "param_count": 7,
      "markup_type": "markdown"
    },
    "title": "AddProjectMarker2",
    "functioncall": {
      "lua": "integer = reaper.AddProjectMarker2(ReaProject proj, boolean isrgn, number pos, number rgnend, string name, integer wantidx, integer color)",
      "cpp": "int AddProjectMarker2(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx, int color)",
      "python": "Int RPR_AddProjectMarker2(ReaProject proj, Boolean isrgn, Float pos, Float rgnend, String name, Int wantidx, Int color)",
      "eel": "int AddProjectMarker2(ReaProject proj, bool isrgn, pos, rgnend, \"name\", int wantidx, int color)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the shown-number of the newly created marker/region"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "proj", "type": "ReaProject" },
          { "identifier": "isrgn", "type": "boolean" },
          { "identifier": "pos", "type": "number" },
          { "identifier": "rgnend", "type": "number" },
          { "identifier": "name", "type": "string" },
          { "identifier": "wantidx", "type": "integer" },
          { "identifier": "color", "type": "integer" }
        ],
        "method_name": "reaper.AddProjectMarker2",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["helperfunctions", "reascript", "lua", "python", "eel", "add", "remove", "commandid"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Adds a ReaScript (returns the new command ID, or 0 if failed) or removes a ReaScript\nReturns &gt;0 on success. \nUse commit==true when adding/removing a single script. \nWhen bulk adding/removing multiple scripts, you can optimize the n-1 first calls with commit==false and commit==true for the last call.            \nThe commandID returned, might change, when addng this script into an other Reaper-installation. \nTo be sure to use the right command-id, use [ReverseNamedCommandLookup()](#ReverseNamedCommandLookup) to get the ActionCommandID, which will never change, until you remove the script.\n\nIf you want to add a script to several sections, you need to add them individually, by calling the function again with the changed section-number.",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "boolean add",
          "description": "true, if it shall be added, false if it shall be removed"
        },
        {
          "identifier": "integer sectionID",
          "description": "the section, in which this script shall appear(e.g. in the Show Actions-Dialog)\n  0, Main\n  100, Main (alt recording) Note: If you already added to main(section 0), this function automatically adds the script to Main(alt) as well.\n  32060, MIDI Editor\n  32061, MIDI Event List Editor\n  32062, MIDI Inline Editor\n  32063, Media Explorer"
        },
        {
          "identifier": "string scriptfn",
          "description": "the filename of the Reascript to be added"
        },
        {
          "identifier": "boolean commit",
          "description": "true, if it shall be committed, false, if you want to add new scripts first. \nCommitting means, that Reaper stores the Reascript-information into the reaper-kb.ini for permanent use. \nIt will be committed at Reaper's exit as well, but if Reaper crashes before exiting properly, your added\nscript might get lost. When adding many Reascripts to Reaper, setting commit to false might help prevail \nressources, as you don't rewrite the reaper-kb.ini file over and over again. However, if you only add a \nfew scripts, this might not be of importance to you."
        }
      ],
      "param_count": 4,
      "markup_type": "plaintext"
    },
    "title": "AddRemoveReaScript",
    "functioncall": {
      "lua": "integer = reaper.AddRemoveReaScript(boolean add, integer sectionID, string scriptfn, boolean commit)",
      "cpp": "int AddRemoveReaScript(bool add, int sectionID, const char* scriptfn, bool commit)",
      "python": "Int RPR_AddRemoveReaScript(Boolean add, Int sectionID, String scriptfn, Boolean commit)",
      "eel": "int AddRemoveReaScript(bool add, int sectionID, \"scriptfn\", bool commit)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer", "description": "the command ID for this script." }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "add", "type": "boolean" },
          { "identifier": "sectionID", "type": "integer" },
          { "identifier": "scriptfn", "type": "string" },
          { "identifier": "commit", "type": "boolean" }
        ],
        "method_name": "reaper.AddRemoveReaScript",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "mediaitem", "item", "track", "empty", "take"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "creates a new take in an item",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaItem item",
          "description": "a MediaItem-object, in which you want to add the new take"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "AddTakeToMediaItem",
    "functioncall": {
      "lua": "MediaItem_Take = reaper.AddTakeToMediaItem(MediaItem item)",
      "cpp": "MediaItem_Take* AddTakeToMediaItem(MediaItem* item)",
      "python": "MediaItem_Take RPR_AddTakeToMediaItem(MediaItem item)",
      "eel": "MediaItem_Take AddTakeToMediaItem(MediaItem item)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "MediaItem_Take", "description": "the newly created MediaItem_Take-object" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "item", "type": "MediaItem" }],
        "method_name": "reaper.AddTakeToMediaItem",
        "return_values": [{ "type": "MediaItem_Take" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Marker Management"],
    "tags": ["markermanagement", "timesignature", "tempo", "marker", "add"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Deprecated. Use [SetTempoTimeSigMarker](#SetTempoTimeSigMarker) with ptidx=-1.",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project in which to add the TempoTimesigMarker, 0 for the current project; can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        },
        { "identifier": "number timepos", "description": "the position in seconds" },
        { "identifier": "number bpm", "description": "the speed in bpm" },
        {
          "identifier": "integer timesig_num",
          "description": "timesignature number : timesig\\_num/timesig\\_denom, e.g. 3/4"
        },
        {
          "identifier": "integer timesig_denom",
          "description": "timesignature denominator : timesig\\_num/timesig\\_denom, e.g. 3/4"
        },
        {
          "identifier": "boolean lineartempochange",
          "description": "true, linear tempo change, false not"
        }
      ],
      "param_count": 6,
      "markup_type": "markdown"
    },
    "title": "AddTempoTimeSigMarker",
    "functioncall": {
      "lua": "boolean = reaper.AddTempoTimeSigMarker(ReaProject proj, number timepos, number bpm, integer timesig_num, integer timesig_denom, boolean lineartempochange)",
      "cpp": "bool AddTempoTimeSigMarker(ReaProject* proj, double timepos, double bpm, int timesig_num, int timesig_denom, bool lineartempochange)",
      "python": "Boolean RPR_AddTempoTimeSigMarker(ReaProject proj, Float timepos, Float bpm, Int timesig_num, Int timesig_denom, Boolean lineartempochange)",
      "eel": "bool AddTempoTimeSigMarker(ReaProject proj, timepos, bpm, int timesig_num, int timesig_denom, bool lineartempochange)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "boolean", "description": "true, if adding was successful; false, if not" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "proj", "type": "ReaProject" },
          { "identifier": "timepos", "type": "number" },
          { "identifier": "bpm", "type": "number" },
          { "identifier": "timesig_num", "type": "integer" },
          { "identifier": "timesig_denom", "type": "integer" },
          { "identifier": "lineartempochange", "type": "boolean" }
        ],
        "method_name": "reaper.AddTempoTimeSigMarker",
        "return_values": [{ "type": "boolean" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Arrangeview Management"],
    "tags": ["arrangeviewmanagement", "view", "zoom", "center"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Sets horizontal zoom in track view.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "number amt",
          "description": "the zoom factor, positive values=zoom in, negative values=zoom out, 0=no zoom"
        },
        {
          "identifier": "integer forceset",
          "description": "forces one amt-zoomfactor(non zero) or allows repeatable zoom-in/zoomout(0)"
        },
        {
          "identifier": "boolean doupd",
          "description": "true, updates the track-view instantly; false, or only when mouse hovers over trackview"
        },
        {
          "identifier": "integer centermode",
          "description": "decides, what shall be in the center of the view. The following are available:\n -1, default selection, as set in the reaper-prefs, \n  0, edit-cursor or playcursor(if it's in the current zoomfactor of the view during playback/recording) in center,\n  1, keeps edit-cursor in center of zoom\n  2, keeps center of view in the center during zoom\n  3, keeps in center of zoom, what is beneath the mousecursor"
        }
      ],
      "param_count": 4,
      "markup_type": "plaintext"
    },
    "title": "adjustZoom",
    "functioncall": {
      "lua": "reaper.adjustZoom(number amt, integer forceset, boolean doupd, integer centermode)",
      "cpp": "void adjustZoom(double amt, int forceset, bool doupd, int centermode)",
      "python": "RPR_adjustZoom(Float amt, Int forceset, Boolean doupd, Int centermode)",
      "eel": "adjustZoom(amt, int forceset, bool doupd, int centermode)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "amt", "type": "number" },
          { "identifier": "forceset", "type": "integer" },
          { "identifier": "doupd", "type": "boolean" },
          { "identifier": "centermode", "type": "integer" }
        ],
        "method_name": "reaper.adjustZoom",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "states", "solo"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "returns, whether any of the tracks is solo in Project proj",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project to be checked for. 0 for current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "title": "AnyTrackSolo",
    "functioncall": {
      "lua": "boolean = reaper.AnyTrackSolo(ReaProject proj)",
      "cpp": "bool AnyTrackSolo(ReaProject* proj)",
      "python": "Boolean RPR_AnyTrackSolo(ReaProject proj)",
      "eel": "bool AnyTrackSolo(ReaProject proj)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "boolean",
          "description": "true if any track is solo; false if not. Covers all solo-states(solo in place, ignore routing, exclusive solo, solo defeat)."
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.AnyTrackSolo",
        "return_values": [{ "type": "boolean" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["api", "exists", "check", "helper"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Returns true if function_name exists in the REAPER API",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "string function_name",
          "description": "the name of the function you want to check the existence for"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "APIExists",
    "functioncall": {
      "lua": "boolean = reaper.APIExists(string function_name)",
      "cpp": "bool APIExists(const char* function_name)",
      "python": "Boolean RPR_APIExists(String function_name)",
      "eel": "bool APIExists(function_name\")"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "boolean", "description": "true, if function_name exists, false if not" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "function_name", "type": "string" }],
        "method_name": "reaper.APIExists",
        "return_values": [{ "type": "boolean" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["api", "test", "check", "hello world"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Displays a message window with \"Hello World\", if the API was successfully called.",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "APITest",
    "functioncall": {
      "lua": "reaper.APITest()",
      "cpp": "void APITest()",
      "python": "RPR_APITest()",
      "eel": "APITest()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.APITest", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": [
      "arrangeviewmanagement",
      "nudge",
      "snap",
      "value",
      "units",
      "trim",
      "position",
      "content",
      "duplicate",
      "editcursor",
      "ms",
      "grid",
      "pixels",
      "frames",
      "samples",
      "measures",
      "beats",
      "length",
      "selection"
    ],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Nudges elements like items, cursor, contents, etc to or by a value you want. Nudges only selected mediaitems.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject project",
          "description": "the project, in which to nudge; 0 for the current project"
        },
        {
          "identifier": "integer nudgeflag",
          "description": "the way to nudge\n&1, set to value(otherwise nudge by values)\n&2, snap"
        },
        {
          "identifier": "integer nudgewhat",
          "description": "what to nudge\n0, position\n1, left trim\n2, left edge\n3, right edge\n4, contents\n5, duplicate\n6, editcursor"
        },
        {
          "identifier": "integer nudgeunits",
          "description": "the unit, in which to nudge\n0, ms\n1, seconds\n2, grid\n3, 256th notes\n...\n15, whole notes\n16, measures.beats (1.15 = 1 measure + 1.5 beats)\n17, samples\n18, frames\n19, pixels \n20, item lengths\n21, item selections"
        },
        {
          "identifier": "number value",
          "description": "amount to nudge by, or value to set to(depending on the settings in nudgeflag and the unit in nudgeunits)"
        },
        {
          "identifier": "boolean reverse",
          "description": "in nudge mode: true nudges left; right doesn't nudge to left"
        },
        {
          "identifier": "integer copies",
          "description": "in nudge duplicate mode, number of copies (otherwise ignored)"
        }
      ],
      "param_count": 7,
      "markup_type": "plaintext"
    },
    "title": "ApplyNudge",
    "functioncall": {
      "lua": "boolean = reaper.ApplyNudge(ReaProject project, integer nudgeflag, integer nudgewhat, integer nudgeunits, number value, boolean reverse, integer copies)",
      "cpp": "bool ApplyNudge(ReaProject* project, int nudgeflag, int nudgewhat, int nudgeunits, double value, bool reverse, int copies)",
      "python": "Boolean RPR_ApplyNudge(ReaProject project, Int nudgeflag, Int nudgewhat, Int nudgeunits, Float value, Boolean reverse, Int copies)",
      "eel": "bool ApplyNudge(ReaProject project, int nudgeflag, int nudgewhat, int nudgeunits, value, bool reverse, int copies)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "boolean", "description": "true, if it worked; false, if it didn't" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "project", "type": "ReaProject" },
          { "identifier": "nudgeflag", "type": "integer" },
          { "identifier": "nudgewhat", "type": "integer" },
          { "identifier": "nudgeunits", "type": "integer" },
          { "identifier": "value", "type": "number" },
          { "identifier": "reverse", "type": "boolean" },
          { "identifier": "copies", "type": "integer" }
        ],
        "method_name": "reaper.ApplyNudge",
        "return_values": [{ "type": "boolean" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["AudioMidi Devicemanagement"],
    "tags": ["audio", "midi", "audiomanagement", "open", "devices"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "open all audio and MIDI devices, if not open",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "Audio_Init",
    "functioncall": {
      "lua": "reaper.Audio_Init()",
      "cpp": "void Audio_Init()",
      "python": "RPR_Audio_Init()",
      "eel": "Audio_Init()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.Audio_Init", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["AudioMidi Devicemanagement"],
    "tags": [""],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "is in pre-buffer? threadsafe",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "Audio_IsPreBuffer",
    "functioncall": {
      "lua": "integer = reaper.Audio_IsPreBuffer()",
      "cpp": "int Audio_IsPreBuffer()",
      "python": "Int RPR_Audio_IsPreBuffer()",
      "eel": "int Audio_IsPreBuffer()"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer", "description": "" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [],
        "method_name": "reaper.Audio_IsPreBuffer",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["AudioMidi Devicemanagement"],
    "tags": ["audio", "midi", "audiomanagement", "running", "devices"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "is audio running at all? threadsafe",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "Audio_IsRunning",
    "functioncall": {
      "lua": "integer = reaper.Audio_IsRunning()",
      "cpp": "int Audio_IsRunning()",
      "python": "Int RPR_Audio_IsRunning()",
      "eel": "int Audio_IsRunning()"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "0, audio is not running; 1, audio is running" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [],
        "method_name": "reaper.Audio_IsRunning",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["AudioMidi Devicemanagement"],
    "tags": ["audio", "midi", "audiomanagement", "quit", "devices"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "close all audio and MIDI devices, if open",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "Audio_Quit",
    "functioncall": {
      "lua": "reaper.Audio_Quit()",
      "cpp": "void Audio_Quit()",
      "python": "RPR_Audio_Quit()",
      "eel": "Audio_Quit()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.Audio_Quit", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.97" },
    "chapers": ["AudioMidi Devicemanagement"],
    "tags": ["audio", "accessor", "get", "statechange"],
    "description": {
      "language": "",
      "prog_lang": "",
      "description": "Returns true if the underlying samples (track or media item take) have changed, but does not update the audio accessor, so the user can selectively call [AudioAccessorValidateState](#AudioAccessorValidateState) only when needed. \n\nSee [CreateTakeAudioAccessor](#CreateTakeAudioAccessor), [CreateTrackAudioAccessor](#CreateTrackAudioAccessor), [DestroyAudioAccessor](#DestroyAudioAccessor), [GetAudioAccessorEndTime](#GetAudioAccessorEndTime), [GetAudioAccessorSamples](#GetAudioAccessorSamples).",
      "markup_type": "markdown"
    },
    "params": { "entries": [] },
    "title": "AudioAccessorStateChanged",
    "functioncall": {
      "lua": "boolean reaper.AudioAccessorStateChanged(AudioAccessor accessor)",
      "cpp": "bool AudioAccessorStateChanged(AudioAccessor* accessor)",
      "python": "Boolean RPR_AudioAccessorStateChanged(AudioAccessor accessor)",
      "eel": "bool AudioAccessorStateChanged(AudioAccessor accessor)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "reaper", "type": "boolean" },
          { "identifier": "accessor", "type": "AudioAccessor" }
        ],
        "method_name": "reaper.AudioAccessorStateChanged",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.97" },
    "chapers": ["AudioMidi Devicemanagement"],
    "tags": ["audio", "accessor", "update", "mediatrack", "mediaitemtake"],
    "description": {
      "language": "",
      "prog_lang": "",
      "description": "Force the accessor to reload its state from the underlying track or media item take. \n\nSee [CreateTakeAudioAccessor](#CreateTakeAudioAccessor), [CreateTrackAudioAccessor](#CreateTrackAudioAccessor), [DestroyAudioAccessor](#DestroyAudioAccessor), [AudioAccessorStateChanged](#AudioAccessorStateChanged), [GetAudioAccessorStartTime](#GetAudioAccessorStartTime), [GetAudioAccessorEndTime](#GetAudioAccessorEndTime), [GetAudioAccessorSamples](#GetAudioAccessorSamples).",
      "markup_type": "markdown"
    },
    "params": { "entries": [] },
    "title": "AudioAccessorUpdate",
    "functioncall": {
      "lua": "reaper.AudioAccessorUpdate(AudioAccessor accessor)",
      "cpp": "void AudioAccessorUpdate(AudioAccessor* accessor)",
      "python": "RPR_AudioAccessorUpdate(AudioAccessor accessor)",
      "eel": "AudioAccessorUpdate(AudioAccessor accessor)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "accessor", "type": "AudioAccessor" }],
        "method_name": "reaper.AudioAccessorUpdate",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Audio Management"],
    "tags": ["audiomanagement", "validate", "audio", "accessor", "item", "take"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Validates the current state of the audio accessor -- must ONLY call this from the main thread. Returns true if the state changed.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "AudioAccessor accessor",
          "description": "the AudioAccessor for a MediaTrack or a MediaItem_take"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "AudioAccessorValidateState",
    "functioncall": {
      "lua": "boolean = reaper.AudioAccessorValidateState(AudioAccessor accessor)",
      "cpp": "bool AudioAccessorValidateState(AudioAccessor* accessor)",
      "python": "Boolean RPR_AudioAccessorValidateState(AudioAccessor accessor)",
      "eel": "bool AudioAccessorValidateState(AudioAccessor accessor)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "boolean",
          "description": "true, if state has changed; false, if state hasn't changed"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "accessor", "type": "AudioAccessor" }],
        "method_name": "reaper.AudioAccessorValidateState",
        "return_values": [{ "type": "boolean" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "track", "bypass", "fx"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Does bypassing of the fx of all tracks.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer bypass",
          "description": "-1, bypass all if not all bypassed,otherwise unbypass all"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "BypassFxAllTracks",
    "functioncall": {
      "lua": "reaper.BypassFxAllTracks(integer bypass)",
      "cpp": "void BypassFxAllTracks(int bypass)",
      "python": "RPR_BypassFxAllTracks(Int bypass)",
      "eel": "BypassFxAllTracks(int bypass)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "bypass", "type": "integer" }],
        "method_name": "reaper.BypassFxAllTracks",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "rec", "arm", "state", "clear", "off"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Clears all armed states of all tracks.",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "ClearAllRecArmed",
    "functioncall": {
      "lua": "reaper.ClearAllRecArmed()",
      "cpp": "void ClearAllRecArmed()",
      "python": "RPR_ClearAllRecArmed()",
      "eel": "ClearAllRecArmed()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.ClearAllRecArmed", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["helperfunctions", "console", "clear", "reaconsole"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Clear the ReaScript console. See [ShowConsoleMsg](#ShowConsoleMsg)",
      "markup_type": "markdown"
    },
    "params": { "entries": [] },
    "title": "ClearConsole",
    "functioncall": {
      "lua": "reaper.ClearConsole()",
      "cpp": "void ClearConsole()",
      "python": "RPR_ClearConsole()",
      "eel": "ClearConsole()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.ClearConsole", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["helperfunctions", "peak", "cache", "clear"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "resets the global peak caches",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "ClearPeakCache",
    "functioncall": {
      "lua": "reaper.ClearPeakCache()",
      "cpp": "void ClearPeakCache()",
      "python": "RPR_ClearPeakCache()",
      "eel": "ClearPeakCache()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.ClearPeakCache", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["colormanagement", "native", "from", "conversion"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Extract RGB values from an OS dependent color. See [ColorToNative](#ColorToNative).\n\nAs Reaper treats colors differently on Mac and Windows, you should always use [ColorFromNative](#ColorFromNative) and [ColorToNative](#ColorToNative).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer col", "description": "the colorvalue to convert from" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "ColorFromNative",
    "functioncall": {
      "lua": "integer r, integer g, integer b = reaper.ColorFromNative(integer col)",
      "cpp": "void ColorFromNative(int col, int* rOut, int* gOut, int* bOut)",
      "python": "(Int col, Int rOut, Int gOut, Int bOut) = RPR_ColorFromNative(col, rOut, gOut, bOut)",
      "eel": "ColorFromNative(int col, int &amp;r, int &amp;g, int &amp;b)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer r", "description": "the value for red, from 0 to 255" },
        { "identifier": "integer g", "description": "the value for green, from 0 to 255" },
        { "identifier": "integer b", "description": "the value for blue, from 0 to 255" }
      ],
      "param_count": 3,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "col", "type": "integer" }],
        "method_name": "reaper.ColorFromNative",
        "return_values": [
          { "identifier": "r", "type": "integer" },
          { "identifier": "g", "type": "integer" },
          { "identifier": "b", "type": "integer" }
        ]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Api-Helper-Functions"],
    "tags": ["colormanagement", "native", "from", "conversion"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See [ColorFromNative](#ColorFromNative)\nAs Reaper treats colors differently on Mac and Windows, you should always use [ColorFromNative](#ColorFromNative) and [ColorToNative](ColorToNative).\n\nWhen using the returned colorvalue, you need to add |0x1000000 at the end of it, like ColorToNative(20,30,40)|0x1000000.",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer r", "description": "the value for red, from 0 to 255" },
        { "identifier": "integer g", "description": "the value for green, from 0 to 255" },
        { "identifier": "integer b", "description": "the value for blue, from 0 to 255" }
      ],
      "param_count": 3,
      "markup_type": "plaintext"
    },
    "title": "ColorToNative",
    "functioncall": {
      "lua": "integer = reaper.ColorToNative(integer r, integer g, integer b)",
      "cpp": "int ColorToNative(int r, int g, int b)",
      "python": "Int RPR_ColorToNative(Int r, Int g, Int b)",
      "eel": "int ColorToNative(int r, int g, int b)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer col",
          "description": "the correct colorvalue, fitting to your system."
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "r", "type": "integer" },
          { "identifier": "g", "type": "integer" },
          { "identifier": "b", "type": "integer" }
        ],
        "method_name": "reaper.ColorToNative",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Automation Management"],
    "tags": ["envelopemanagement", "automation items", "count", "envelopes"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Returns the number of automation items on this envelope. See [GetSetAutomationItemInfo](#GetSetAutomationItemInfo).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "TrackEnvelope env",
          "description": "the envelope-object for the envelope-lane"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountAutomationItems",
    "functioncall": {
      "lua": "integer = reaper.CountAutomationItems(TrackEnvelope env)",
      "cpp": "int CountAutomationItems(TrackEnvelope* env)",
      "python": "Int RPR_CountAutomationItems(TrackEnvelope env)",
      "eel": "int CountAutomationItems(TrackEnvelope env)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer", "description": "number of automation items" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "env", "type": "TrackEnvelope" }],
        "method_name": "reaper.CountAutomationItems",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.979" },
    "chapers": ["Envelope Management"],
    "tags": ["envelopemanagement", "envelopes", "count", "points"],
    "description": {
      "language": "",
      "prog_lang": "",
      "description": "Returns the number of points in the envelope. See [#CountEnvelopePointsEx](#CountEnvelopePointsEx)",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "TrackEnvelope envelope",
          "description": "the TrackEnvelope-object, in which to count for the envelope-points"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountEnvelopePoints",
    "functioncall": {
      "lua": "integer = reaper.CountEnvelopePoints(TrackEnvelope envelope)",
      "cpp": "int CountEnvelopePoints(TrackEnvelope* envelope)",
      "python": "Int RPR_CountEnvelopePoints(TrackEnvelope envelope)",
      "eel": "int CountEnvelopePoints(TrackEnvelope envelope)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the number of envelope-points in the envelopeobject envelope"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "envelope", "type": "TrackEnvelope" }],
        "method_name": "reaper.CountEnvelopePoints",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.979" },
    "chapers": ["Envelope Management"],
    "tags": ["envelopemanagement", "envelopes", "count", "points", "automation items"],
    "description": {
      "language": "",
      "prog_lang": "",
      "description": "Returns the number of points in the envelope.\nautoitem\\_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem\\_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\n\nSee [GetEnvelopePointEx](#GetEnvelopePointEx), [SetEnvelopePointEx](#SetEnvelopePointEx), [InsertEnvelopePointEx](#InsertEnvelopePointEx), [DeleteEnvelopePointEx](#DeleteEnvelopePointEx).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "TrackEnvelope envelope",
          "description": "the TrackEnvelope-object, in which to count for the envelope-points"
        },
        {
          "identifier": "integer autoitem_idx",
          "description": "-1, for the underlying envelope, 0, for the first automation item on the envelope, etc."
        }
      ],
      "param_count": 2,
      "markup_type": "plaintext"
    },
    "title": "CountEnvelopePointsEx",
    "functioncall": {
      "lua": "integer = reaper.CountEnvelopePointsEx(TrackEnvelope envelope, integer autoitem_idx)",
      "cpp": "int CountEnvelopePointsEx(TrackEnvelope* envelope, int autoitem_idx)",
      "python": "Int RPR_CountEnvelopePointsEx(TrackEnvelope envelope, Int autoitem_idx)",
      "eel": "int CountEnvelopePointsEx(TrackEnvelope envelope, int autoitem_idx)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the number of envelope-points in the envelopeobject envelope"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "envelope", "type": "TrackEnvelope" },
          { "identifier": "autoitem_idx", "type": "integer" }
        ],
        "method_name": "reaper.CountEnvelopePointsEx",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "count", "mediaitems"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "count the number of items in the project (proj=0 for active project)",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project, in which to count for the number of items; 0 for the current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "title": "CountMediaItems",
    "functioncall": {
      "lua": "integer = reaper.CountMediaItems(ReaProject proj)",
      "cpp": "int CountMediaItems(ReaProject* proj)",
      "python": "Int RPR_CountMediaItems(ReaProject proj)",
      "eel": "int CountMediaItems(ReaProject proj)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "the number of MediaItems in a project" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.CountMediaItems",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Marker Management"],
    "tags": ["markermanagement", "count", "all", "markers", "regions"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "returns the number of all markers and regions, as well as all markers and all regions in a project.\nnum_markersOut and num_regionsOut may be NULL.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project, in which to count the markers; 0 for current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "title": "CountProjectMarkers",
    "functioncall": {
      "lua": "integer retval, number num_markers, number num_regions = reaper.CountProjectMarkers(ReaProject proj)",
      "cpp": "int CountProjectMarkers(ReaProject* proj, int* num_markersOut, int* num_regionsOut)",
      "python": "(Int retval, ReaProject proj, Int num_markersOut, Int num_regionsOut) = RPR_CountProjectMarkers(proj, num_markersOut, num_regionsOut)",
      "eel": "int CountProjectMarkers(ReaProject proj, int &amp;num_markers, int &amp;num_regions)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer retval", "description": "all markers and regions in the project" },
        {
          "identifier": "integer num_markers",
          "description": "the number of markers in the project"
        },
        {
          "identifier": "integer num_regions",
          "description": "the number of regions in the project"
        }
      ],
      "param_count": 3,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.CountProjectMarkers",
        "return_values": [
          { "identifier": "retval", "type": "integer" },
          { "identifier": "num_markers", "type": "number" },
          { "identifier": "num_regions", "type": "number" }
        ]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "count", "selected", "mediaitem"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "count the number of selected items in the project (proj=0 for active project)",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project, in which to count for the selected mediaitems; 0 for the current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "title": "CountSelectedMediaItems",
    "functioncall": {
      "lua": "integer = reaper.CountSelectedMediaItems(ReaProject proj)",
      "cpp": "int CountSelectedMediaItems(ReaProject* proj)",
      "python": "Int RPR_CountSelectedMediaItems(ReaProject proj)",
      "eel": "int CountSelectedMediaItems(ReaProject proj)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "the number of selected items in the project" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.CountSelectedMediaItems",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "track", "selected", "count"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Count the number of selected tracks in the project. \nThis function ignores the master track, see [CountSelectedTracks2](#CountSelectedTracks2)",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project in which to count the selected tracks; 0 for current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "title": "CountSelectedTracks",
    "functioncall": {
      "lua": "integer = reaper.CountSelectedTracks(ReaProject proj)",
      "cpp": "int CountSelectedTracks(ReaProject* proj)",
      "python": "Int RPR_CountSelectedTracks(ReaProject proj)",
      "eel": "int CountSelectedTracks(ReaProject proj)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "the number of selected tracks in the project" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.CountSelectedTracks",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "selected", "track", "master", "count"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Count the number of selected tracks in the project.\nif you set wantmaster to true, it will include the master track as well.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the number of the project in which to count the selected tracks; 0 for current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        },
        {
          "identifier": "boolean wantmaster",
          "description": "true, if you want to count the master-track as well; false, if you don't want to count it"
        }
      ],
      "param_count": 2,
      "markup_type": "markdown"
    },
    "title": "CountSelectedTracks2",
    "functioncall": {
      "lua": "integer = reaper.CountSelectedTracks2(ReaProject proj, boolean wantmaster)",
      "cpp": "int CountSelectedTracks2(ReaProject* proj, bool wantmaster)",
      "python": "Int RPR_CountSelectedTracks2(ReaProject proj, Boolean wantmaster)",
      "eel": "int CountSelectedTracks2(ReaProject proj, bool wantmaster)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "the number of selected tracks in your project" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "proj", "type": "ReaProject" },
          { "identifier": "wantmaster", "type": "boolean" }
        ],
        "method_name": "reaper.CountSelectedTracks2",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "take", "envelope"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "See [GetTakeEnvelope](#GetTakeEnvelope)",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaItem_Take take",
          "description": "the mediaitem-object for a certain take"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountTakeEnvelopes",
    "functioncall": {
      "lua": "integer = reaper.CountTakeEnvelopes(MediaItem_Take take)",
      "cpp": "int CountTakeEnvelopes(MediaItem_Take* take)",
      "python": "Int RPR_CountTakeEnvelopes(MediaItem_Take take)",
      "eel": "int CountTakeEnvelopes(MediaItem_Take take)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "number of envelopes of this take of a mediaitem"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "take", "type": "MediaItem_Take" }],
        "method_name": "reaper.CountTakeEnvelopes",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "count", "takes", "mediaitem"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "count the number of takes in the item",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "MediaItem item", "description": "the mediaitem to count the takes of" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountTakes",
    "functioncall": {
      "lua": "integer = reaper.CountTakes(MediaItem item)",
      "cpp": "int CountTakes(MediaItem* item)",
      "python": "Int RPR_CountTakes(MediaItem item)",
      "eel": "int CountTakes(MediaItem item)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer", "description": "the number of takes in a mediaitem" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "item", "type": "MediaItem" }],
        "method_name": "reaper.CountTakes",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "count", "fx", "parameter", "knobs", "track"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Count the number of FX parameter knobs displayed on the track control panel.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject project",
          "description": "the project, in which to count the knobs"
        },
        { "identifier": "MediaTrack track", "description": "the track of which to count the knobs" }
      ],
      "param_count": 2,
      "markup_type": "plaintext"
    },
    "title": "CountTCPFXParms",
    "functioncall": {
      "lua": "integer = reaper.CountTCPFXParms(ReaProject project, MediaTrack track)",
      "cpp": "int CountTCPFXParms(ReaProject* project, MediaTrack* track)",
      "python": "Int RPR_CountTCPFXParms(ReaProject project, MediaTrack track)",
      "eel": "int CountTCPFXParms(ReaProject project, MediaTrack track)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer", "description": "the number of FX-parameter-knobs " }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "project", "type": "ReaProject" },
          { "identifier": "track", "type": "MediaTrack" }
        ],
        "method_name": "reaper.CountTCPFXParms",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Marker Management"],
    "tags": ["markermanagement", "tempo", "timesignature", "count"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Count the number of tempo/time signature markers in the project. See [GetTempoTimeSigMarker](#GetTempoTimeSigMarker), [SetTempoTimeSigMarker](#SetTempoTimeSigMarker), [AddTempoTimeSigMarker](#AddTempoTimeSigMarker), [DeleteTempoTimeSigMarker](#DeleteTempoTimeSigMarker).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "project number; 0 for the current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountTempoTimeSigMarkers",
    "functioncall": {
      "lua": "integer = reaper.CountTempoTimeSigMarkers(ReaProject proj)",
      "cpp": "int CountTempoTimeSigMarkers(ReaProject* proj)",
      "python": "Int RPR_CountTempoTimeSigMarkers(ReaProject proj)",
      "eel": "int CountTempoTimeSigMarkers(ReaProject proj)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the number of tempo/time-signature markers in the project."
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.CountTempoTimeSigMarkers",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Envelope Management"],
    "tags": ["envelopemanagement", "count", "track-envelopes", "track"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Counts the number of track-envelopes of a certain track.\nsee [GetTrackEnvelope](#GetTrackEnvelope)",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaTrack track",
          "description": "the object of the track to count it's envelopes"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountTrackEnvelopes",
    "functioncall": {
      "lua": "integer = reaper.CountTrackEnvelopes(MediaTrack track)",
      "cpp": "int CountTrackEnvelopes(MediaTrack* track)",
      "python": "Int RPR_CountTrackEnvelopes(MediaTrack track)",
      "eel": "int CountTrackEnvelopes(MediaTrack track)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "the number of track-envelopes in a track" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "track", "type": "MediaTrack" }],
        "method_name": "reaper.CountTrackEnvelopes",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "track", "count", "mediaitem"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "count the number of items in the track",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "MediaTrack track", "description": "the MediaTrack to count the items of" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CountTrackMediaItems",
    "functioncall": {
      "lua": "integer = reaper.CountTrackMediaItems(MediaTrack track)",
      "cpp": "int CountTrackMediaItems(MediaTrack* track)",
      "python": "Int RPR_CountTrackMediaItems(MediaTrack track)",
      "eel": "int CountTrackMediaItems(MediaTrack track)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "integer", "description": "the number of mediaitems in the track" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "track", "type": "MediaTrack" }],
        "method_name": "reaper.CountTrackMediaItems",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "count", "track"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "count the number of tracks in the project (proj=0 for active project)",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "ReaProject proj",
          "description": "the project in which to count the tracks; 0 for the current project. Can also be a ReaProject-object, as returned by [EnumProjects](#EnumProjects)"
        }
      ],
      "param_count": 1,
      "markup_type": "markdown"
    },
    "title": "CountTracks",
    "functioncall": {
      "lua": "integer = reaper.CountTracks(ReaProject proj)",
      "cpp": "int CountTracks(ReaProject* proj)",
      "python": "Int RPR_CountTracks(ReaProject proj)",
      "eel": "int CountTracks(ReaProject proj)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the number of tracks in the project, excluding the master-track."
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "proj", "type": "ReaProject" }],
        "method_name": "reaper.CountTracks",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Mediaitem Management"],
    "tags": ["mediaitemmanagement", "midi", "track", "mediaitem"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaTrack track",
          "description": "the object of the track, in which to create this mediaitem"
        },
        {
          "identifier": "number starttime",
          "description": "starttime of the item in seconds, unless qnIn is set to true"
        },
        {
          "identifier": "number endtime",
          "description": "endtime of the item in seconds, unless qnIn is set to true"
        },
        {
          "identifier": "boolean qnIn",
          "description": "unknown; can be set to true, or false or be omitted"
        }
      ],
      "param_count": 4,
      "markup_type": "plaintext"
    },
    "title": "CreateNewMIDIItemInProj",
    "functioncall": {
      "lua": "MediaItem = reaper.CreateNewMIDIItemInProj(MediaTrack track, number starttime, number endtime, optional boolean qnIn)",
      "cpp": "MediaItem* CreateNewMIDIItemInProj(MediaTrack* track, double starttime, double endtime, const bool* qnInOptional)",
      "python": "MediaItem RPR_CreateNewMIDIItemInProj(MediaTrack track, Float starttime, Float endtime, const bool qnInOptional)",
      "eel": "MediaItem CreateNewMIDIItemInProj(MediaTrack track, starttime, endtime, optional bool qnIn)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "MediaItem", "description": "the newly created MIDI-mediaitem." }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "track", "type": "MediaTrack" },
          { "identifier": "starttime", "type": "number" },
          { "identifier": "endtime", "type": "number" },
          { "identifier": "boolean", "type": "optional" }
        ],
        "method_name": "reaper.CreateNewMIDIItemInProj",
        "return_values": [{ "type": "MediaItem" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.97" },
    "chapers": ["Audio Management"],
    "tags": ["audiomanagement", "audio", "accessor", "create", "item", "take"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Create an audio accessor object for this take. Must only call from the main thread. \n\nSee [CreateTrackAudioAccessor](#CreateTrackAudioAccessor), [DestroyAudioAccessor](#DestroyAudioAccessor), [AudioAccessorStateChanged](#AudioAccessorStateChanged), [GetAudioAccessorStartTime](#GetAudioAccessorStartTime), [GetAudioAccessorEndTime](#GetAudioAccessorEndTime), [GetAudioAccessorSamples](#GetAudioAccessorSamples).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaItem_Take take",
          "description": "the take from a MediaItem-object, of which you want to create a new AudioAccessor"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CreateTakeAudioAccessor",
    "functioncall": {
      "lua": "AudioAccessor = reaper.CreateTakeAudioAccessor(MediaItem_Take take)",
      "cpp": "AudioAccessor* CreateTakeAudioAccessor(MediaItem_Take* take)",
      "python": "AudioAccessor RPR_CreateTakeAudioAccessor(MediaItem_Take take)",
      "eel": "AudioAccessor CreateTakeAudioAccessor(MediaItem_Take take)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "AudioAccessor", "description": "the newly created AudioAccessor" }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "take", "type": "MediaItem_Take" }],
        "method_name": "reaper.CreateTakeAudioAccessor",
        "return_values": [{ "type": "AudioAccessor" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.97" },
    "chapers": ["Audio Management"],
    "tags": ["audiomanagement", "audio", "accessor", "create", "track"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Create an audio accessor object for this track. Must only call from the main thread. See [CreateTakeAudioAccessor](#CreateTakeAudioAccessor), [DestroyAudioAccessor](#DestroyAudioAccessor), [AudioAccessorStateChanged](#AudioAccessorStateChanged), [GetAudioAccessorStartTime](#GetAudioAccessorStartTime), [GetAudioAccessorEndTime](#GetAudioAccessorEndTime), [GetAudioAccessorSamples](#GetAudioAccessorSamples).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaTrack track",
          "description": "the MediaTrack, of which you want to create an AudioAccessor"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CreateTrackAudioAccessor",
    "functioncall": {
      "lua": "AudioAccessor = reaper.CreateTrackAudioAccessor(MediaTrack track)",
      "cpp": "AudioAccessor* CreateTrackAudioAccessor(MediaTrack* track)",
      "python": "AudioAccessor RPR_CreateTrackAudioAccessor(MediaTrack track)",
      "eel": "AudioAccessor CreateTrackAudioAccessor(MediaTrack track)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "AudioAccessor",
          "description": "the newly created AudioAccessor for this MediaTrack"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "track", "type": "MediaTrack" }],
        "method_name": "reaper.CreateTrackAudioAccessor",
        "return_values": [{ "type": "AudioAccessor" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "create", "routing", "hwout", "hardware out", "send", "receive"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output (desttrInOptional==NULL) with default properties, return &gt;=0 on success (== new send/receive index). See [RemoveTrackSend](#RemoveTrackSend), [GetSetTrackSendInfo](#GetSetTrackSendInfo), [GetTrackSendInfo\\_Value](#GetTrackSendInfo_Value), [SetTrackSendInfo\\_Value](#SetTrackSendInfo_Value).\n\nFor ReaRoute-users: the outputs are hardware outputs, but with 512 added to the destination channel index (512 is the first rearoute channel, 513 the second, etc).",
      "markup_type": "markdown"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaTrack tr",
          "description": "the MediaTrack in which to create the send/hwout"
        },
        {
          "identifier": "MediaTrack desttrIn",
          "description": "destination track input; \na MediaTrack-object, creates a new send to tr from MediaTrack-object; \nnil(or no MediaTrack-object), creates a new hardware-output"
        }
      ],
      "param_count": 2,
      "markup_type": "plaintext"
    },
    "title": "CreateTrackSend",
    "functioncall": {
      "lua": "integer = reaper.CreateTrackSend(MediaTrack tr, MediaTrack desttrIn)",
      "cpp": "int CreateTrackSend(MediaTrack* tr, MediaTrack* desttrInOptional)",
      "python": "Int RPR_CreateTrackSend(MediaTrack tr, MediaTrack desttrInOptional)",
      "eel": "int CreateTrackSend(MediaTrack tr, MediaTrack desttrIn)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer",
          "description": "the id of the new HWOut or Send created. HWOut and Send have their own individual index-numbering."
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "tr", "type": "MediaTrack" },
          { "identifier": "desttrIn", "type": "MediaTrack" }
        ],
        "method_name": "reaper.CreateTrackSend",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Miscellaneous"],
    "tags": [""],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "call this to force flushing of the undo states after using CSurf_On*Change()",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [{ "identifier": "boolean force", "description": "" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CSurf_FlushUndo",
    "functioncall": {
      "lua": "reaper.CSurf_FlushUndo(boolean force)",
      "cpp": "void CSurf_FlushUndo(bool force)",
      "python": "RPR_CSurf_FlushUndo(Boolean force)",
      "eel": "CSurf_FlushUndo(bool force)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "force", "type": "boolean" }],
        "method_name": "reaper.CSurf_FlushUndo",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": [""],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        { "identifier": "MediaTrack trackid", "description": "" },
        { "identifier": "integer isPan", "description": "" }
      ],
      "param_count": 2,
      "markup_type": "plaintext"
    },
    "title": "CSurf_GetTouchState",
    "functioncall": {
      "lua": "boolean = reaper.CSurf_GetTouchState(MediaTrack trackid, integer isPan)",
      "cpp": "bool CSurf_GetTouchState(MediaTrack* trackid, int isPan)",
      "python": "Boolean RPR_CSurf_GetTouchState(MediaTrack trackid, Int isPan)",
      "eel": "bool CSurf_GetTouchState(MediaTrack trackid, int isPan)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "boolean", "description": "" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "trackid", "type": "MediaTrack" },
          { "identifier": "isPan", "type": "integer" }
        ],
        "method_name": "reaper.CSurf_GetTouchState",
        "return_values": [{ "type": "boolean" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Transport Management"],
    "tags": ["transportmanagement", "move", "cursor", "end", "project"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Moves the cursor to the end of the last item in the project.",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "CSurf_GoEnd",
    "functioncall": {
      "lua": "reaper.CSurf_GoEnd()",
      "cpp": "void CSurf_GoEnd()",
      "python": "RPR_CSurf_GoEnd()",
      "eel": "CSurf_GoEnd()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.CSurf_GoEnd", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Transport Management"],
    "tags": ["transportmanagement", "move", "cursor", "start", "project"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Moves the cursor to the start of the project.",
      "markup_type": "plaintext"
    },
    "params": { "entries": [] },
    "title": "CSurf_GoStart",
    "functioncall": {
      "lua": "reaper.CSurf_GoStart()",
      "cpp": "void CSurf_GoStart()",
      "python": "RPR_CSurf_GoStart()",
      "eel": "CSurf_GoStart()"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": { "parameters": [], "method_name": "reaper.CSurf_GoStart", "return_values": [] }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "count", "tracks", "visible", "invisible"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "counts the number of tracks, or the number of visible tracks, when mcpView is set to true.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "boolean mcpView",
          "description": "true, only return the number of tracks visible in MCP; false, count all tracks, incl. invisible"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CSurf_NumTracks",
    "functioncall": {
      "lua": "integer = reaper.CSurf_NumTracks(boolean mcpView)",
      "cpp": "int CSurf_NumTracks(bool mcpView)",
      "python": "Int RPR_CSurf_NumTracks(Boolean mcpView)",
      "eel": "int CSurf_NumTracks(bool mcpView)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [{ "identifier": "integer", "description": "number of tracks" }],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "mcpView", "type": "boolean" }],
        "method_name": "reaper.CSurf_NumTracks",
        "return_values": [{ "type": "integer" }]
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Arrangeview Management"],
    "tags": ["arrangeviewmanagement", "zoom", "vertical", "scroll", "arrange", "view"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Zoom or scroll the Arrangeview vertically. \nThe stepsize with scrolling is track by track.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer whichdir",
          "description": "into which (zoom-)direction to change\n  0, move arrangeview upward(one track each step)/zoom in\n  1, move arrangeview downward(one track each step)/zoom out"
        },
        {
          "identifier": "boolean wantzoom",
          "description": "true, adjust vertical zoom; false, adjust vertical scrolling"
        }
      ],
      "param_count": 2,
      "markup_type": "plaintext"
    },
    "title": "CSurf_OnArrow",
    "functioncall": {
      "lua": "reaper.CSurf_OnArrow(integer whichdir, boolean wantzoom)",
      "cpp": "void CSurf_OnArrow(int whichdir, bool wantzoom)",
      "python": "RPR_CSurf_OnArrow(Int whichdir, Boolean wantzoom)",
      "eel": "CSurf_OnArrow(int whichdir, bool wantzoom)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "whichdir", "type": "integer" },
          { "identifier": "wantzoom", "type": "boolean" }
        ],
        "method_name": "reaper.CSurf_OnArrow",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Transport Management"],
    "tags": ["transportmanagement", "cursor", "forward", "jump", "seekplay"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Moves editcursor forward, and optionally with seekplay.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "integer seekplay",
          "description": "how to move the editcursor forward\n  0, move cursor forward in small steps. Stepsize depends on horizontal zoomfactor.\n  1, move cursor forward, in half-second steps when stopped; when playing it jumps ahead with playing restarting at editcursor"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "title": "CSurf_OnFwd",
    "functioncall": {
      "lua": "reaper.CSurf_OnFwd(integer seekplay)",
      "cpp": "void CSurf_OnFwd(int seekplay)",
      "python": "RPR_CSurf_OnFwd(Int seekplay)",
      "eel": "CSurf_OnFwd(int seekplay)"
    },
    "return_values": { "entries": [] },
    "signatures": {
      "lua": {
        "parameters": [{ "identifier": "seekplay", "type": "integer" }],
        "method_name": "reaper.CSurf_OnFwd",
        "return_values": []
      }
    }
  },
  {
    "source_document": "reaper-apidocs.USDocML",
    "target_document": "Reaper_Api_Documentation",
    "requires": { "Lua": "5.3", "Reaper": "5.62" },
    "chapers": ["Track Management"],
    "tags": ["trackmanagement", "fx", "set", "toggle", "chain"],
    "description": {
      "language": "",
      "prog_lang": "*",
      "description": "Sets/toggles activation of FX-Chain.",
      "markup_type": "plaintext"
    },
    "params": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "MediaTrack trackid",
          "description": "the MediaTrack, whose FX-chain you want to de-/activate"
        },
        {
          "identifier": "integer en",
          "description": "activation state of FX-chain\n  -1, toggle FX-chain on/off\n   0, set FX-chain off\n   1, set FX-chain on"
        }
      ],
      "param_count": 2,
      "markup_type": "plaintext"
    },
    "title": "CSurf_OnFXChange",
    "functioncall": {
      "lua": "boolean = reaper.CSurf_OnFXChange(MediaTrack trackid, integer en)",
      "cpp": "bool CSurf_OnFXChange(MediaTrack* trackid, int en)",
      "python": "Boolean RPR_CSurf_OnFXChange(MediaTrack trackid, Int en)",
      "eel": "bool CSurf_OnFXChange(MediaTrack trackid, int en)"
    },
    "return_values": {
      "prog_lang": "*",
      "entries": [
        {
          "identifier": "boolean",
          "description": "true, if FX-chain is activated; false, if FX-chain is deactivated"
        }
      ],
      "param_count": 1,
      "markup_type": "plaintext"
    },
    "signatures": {
      "lua": {
        "parameters": [
          { "identifier": "trackid", "type": "MediaTrack" },
          { "identifier": "en", "type": "integer" }
        ],
        "method_name": "reaper.CSurf_OnFXChange",
        "return_values": [{ "type": "boolean" }]
      }
    }
  }
]
